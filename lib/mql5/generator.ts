export type GeneratorParams = {
  symbol: string;
  timeframe: string;
  lot: number;
  stopLossPoints: number;
  takeProfitPoints: number;
  trailingStopPoints: number;
  template: "custom" | "ma" | "rsi" | "breakout";
  maFast: number;
  maSlow: number;
  rsiPeriod: number;
  rsiBuy: number;
  rsiSell: number;
  breakoutBars: number;
};

export function generateMql5ExpertAdvisor(p: GeneratorParams): string {
  const header = `//+------------------------------------------------------------------+\n`+
`//|              Generated by MT5 Strategy Toolkit                  |\n`+
`//|              https://agentic-1b20e57b.vercel.app                |\n`+
`//+------------------------------------------------------------------+\n`+
`#property strict\n`+
`#include <Trade/Trade.mqh>\n`+
`CTrade trade;\n`+
`input double InpLots = ${p.lot.toFixed(2)};\n`+
`input int InpStopLoss = ${Math.max(0, Math.floor(p.stopLossPoints))};\n`+
`input int InpTakeProfit = ${Math.max(0, Math.floor(p.takeProfitPoints))};\n`+
`input int InpTrailing = ${Math.max(0, Math.floor(p.trailingStopPoints))};\n`+
`// Template: ${p.template}\n\n`;

  const helpers = `int ticketBuy = -1;\nint ticketSell = -1;\n\n`+
`bool HasOpenBuy() { return PositionSelect(Symbol()) && (PositionGetInteger(POSITION_TYPE) == POSITION_TYPE_BUY); }\n`+
`bool HasOpenSell() { return PositionSelect(Symbol()) && (PositionGetInteger(POSITION_TYPE) == POSITION_TYPE_SELL); }\n\n`+
`void ManageTrailingStop() {\n  if(!PositionSelect(Symbol())) return;\n  if(InpTrailing <= 0) return;\n  long type = (long)PositionGetInteger(POSITION_TYPE);\n  double priceOpen = PositionGetDouble(POSITION_PRICE_OPEN);\n  double priceCurrent = (type == POSITION_TYPE_BUY) ? SymbolInfoDouble(Symbol(), SYMBOL_BID) : SymbolInfoDouble(Symbol(), SYMBOL_ASK);\n  double sl = PositionGetDouble(POSITION_SL);\n  double point = SymbolInfoDouble(Symbol(), SYMBOL_POINT);\n  double newSL;\n  if(type == POSITION_TYPE_BUY) {\n    newSL = priceCurrent - InpTrailing * point;\n    if(newSL > sl && newSL > priceOpen) trade.PositionModify(Symbol(), newSL, PositionGetDouble(POSITION_TP));\n  } else {\n    newSL = priceCurrent + InpTrailing * point;\n    if(newSL < sl && newSL < priceOpen) trade.PositionModify(Symbol(), newSL, PositionGetDouble(POSITION_TP));\n  }\n}\n\n`;

  const signal = buildSignalBlock(p);

  const trading = `void EnterBuy() {\n  if(HasOpenBuy()) return;\n  double sl = 0, tp = 0;\n  double point = SymbolInfoDouble(Symbol(), SYMBOL_POINT);\n  if(InpStopLoss > 0) sl = SymbolInfoDouble(Symbol(), SYMBOL_BID) - InpStopLoss * point;\n  if(InpTakeProfit > 0) tp = SymbolInfoDouble(Symbol(), SYMBOL_BID) + InpTakeProfit * point;\n  trade.Buy(InpLots, NULL, 0.0, sl, tp);\n}\n\n`+
`void EnterSell() {\n  if(HasOpenSell()) return;\n  double sl = 0, tp = 0;\n  double point = SymbolInfoDouble(Symbol(), SYMBOL_POINT);\n  if(InpStopLoss > 0) sl = SymbolInfoDouble(Symbol(), SYMBOL_ASK) + InpStopLoss * point;\n  if(InpTakeProfit > 0) tp = SymbolInfoDouble(Symbol(), SYMBOL_ASK) - InpTakeProfit * point;\n  trade.Sell(InpLots, NULL, 0.0, sl, tp);\n}\n\n`+
`int OnInit(){ return(INIT_SUCCEEDED); }\n`+
`void OnDeinit(const int reason){}\n`+
`void OnTick(){\n  if(BuySignal()) EnterBuy();\n  if(SellSignal()) EnterSell();\n  ManageTrailingStop();\n}\n`;

  return header + helpers + signal + trading;
}

function buildSignalBlock(p: GeneratorParams): string {
  if (p.template === "ma") {
    return `// MA Cross\n`+
`input int FastMA = ${p.maFast};\n`+
`input int SlowMA = ${p.maSlow};\n`+
`double maFastPrev, maFastCurr, maSlowPrev, maSlowCurr;\n\n`+
`bool BuySignal(){\n  maFastPrev = iMA(NULL, ${p.timeframe}, FastMA, 0, MODE_EMA, PRICE_CLOSE, 1);\n  maSlowPrev = iMA(NULL, ${p.timeframe}, SlowMA, 0, MODE_EMA, PRICE_CLOSE, 1);\n  maFastCurr = iMA(NULL, ${p.timeframe}, FastMA, 0, MODE_EMA, PRICE_CLOSE, 0);\n  maSlowCurr = iMA(NULL, ${p.timeframe}, SlowMA, 0, MODE_EMA, PRICE_CLOSE, 0);\n  return (maFastPrev <= maSlowPrev) && (maFastCurr > maSlowCurr);\n}\n\n`+
`bool SellSignal(){\n  maFastPrev = iMA(NULL, ${p.timeframe}, FastMA, 0, MODE_EMA, PRICE_CLOSE, 1);\n  maSlowPrev = iMA(NULL, ${p.timeframe}, SlowMA, 0, MODE_EMA, PRICE_CLOSE, 1);\n  maFastCurr = iMA(NULL, ${p.timeframe}, FastMA, 0, MODE_EMA, PRICE_CLOSE, 0);\n  maSlowCurr = iMA(NULL, ${p.timeframe}, SlowMA, 0, MODE_EMA, PRICE_CLOSE, 0);\n  return (maFastPrev >= maSlowPrev) && (maFastCurr < maSlowCurr);\n}\n\n`;
  }
  if (p.template === "rsi") {
    return `// RSI Reversal\n`+
`input int RSIPeriod = ${p.rsiPeriod};\n`+
`input int RSIBuy = ${p.rsiBuy};\n`+
`input int RSISell = ${p.rsiSell};\n\n`+
`bool BuySignal(){\n  double rsi = iRSI(NULL, ${p.timeframe}, RSIPeriod, PRICE_CLOSE, 0);\n  return (rsi < RSIBuy);\n}\n\n`+
`bool SellSignal(){\n  double rsi = iRSI(NULL, ${p.timeframe}, RSIPeriod, PRICE_CLOSE, 0);\n  return (rsi > RSISell);\n}\n\n`;
  }
  if (p.template === "breakout") {
    return `// Range Breakout\n`+
`input int RangeBars = ${p.breakoutBars};\n\n`+
`void HighestLowest(int bars, double &hi, double &lo){\n  hi = iHigh(NULL, ${p.timeframe}, iHighest(NULL, ${p.timeframe}, MODE_HIGH, bars, 1));\n  lo = iLow(NULL, ${p.timeframe}, iLowest(NULL, ${p.timeframe}, MODE_LOW, bars, 1));\n}\n\n`+
`bool BuySignal(){\n  double hi, lo; HighestLowest(RangeBars, hi, lo);\n  double price = SymbolInfoDouble(Symbol(), SYMBOL_ASK);\n  return price > hi;\n}\n\n`+
`bool SellSignal(){\n  double hi, lo; HighestLowest(RangeBars, hi, lo);\n  double price = SymbolInfoDouble(Symbol(), SYMBOL_BID);\n  return price < lo;\n}\n\n`;
  }
  // custom minimal signals (no-op)
  return `bool BuySignal(){ return false; }\n\nbool SellSignal(){ return false; }\n\n`;
}
